## 浏览器渲染模块

### 按照渲染的时间顺序，可分为几个阶段：构建DOM树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。每个阶段都有输入的内容；处理过程；输出内容。

- 构建DOM树   
> 略

- 样式计算

> 样式计算的目的是为了计算出DOM节点中每个元素的具体样式，这个阶段大体可分为三步来完成。
>
>> - 把CSS转换为浏览器能够理解的结构（-> styleSheets）控制台中输入 document.styleSheets 就可以查看该结构；
>
>> - 转换样式表中的属性值，使其标准化（简单理解为把一些相对值计算为绝对值，比如em转换为px等）；
>
>> - 计算出DOM树中每个节点的具体样式；

- 布局阶段

> 计算出DOM树中可见元素的几何位置叫做布局；
>
> Chrome在布局阶段需要完成两个任务：创建布局树和布局计算；
>
>> - 创建布局树 DOM树中含有很多不可见的元素，比如head标签，以及使用了display: none属性的元素。所以在显示之前，我们还要额外地构建一棵只包含可见元素布局树。
>
>> - 布局计算 

- 分层

> 渲染引擎需要为特定的节点生成专用的涂层，并生成一棵对应的图层树(LayerTree)。
>
>> 浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。
>> 通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。那么需要满足什么条件，渲染引擎才会为特定的节点创建新的层呢？
>> - 拥有层叠上下文属性的元素会被提升为单独的一层。
>> - 需要裁剪的地方会被创建为图层。

- 图层绘制

> 在完成图层树的构建之后，渲染引擎会对图层中的每个图层进行绘制。
>
>> 渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表。

- 栅格化操作

> 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。
>> 当图层的绘制列表准备好之后，主线程会把该绘制列表提交给合成线程。
>> 在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口（viewport），用户只能看到页面的很小的一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是256 X 256 或者 512 X 512，然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。
>>
>> 通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。

- 合成和显示

> 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了。

- 总结   
+ 渲染进程将 HTML 内容转换为能够读懂的**DOM 树**结构;
+ 渲染引擎将 CSS 样式表转化为浏览器可以理解的**styleSheets**，计算出 DOM 节点的样式;
+ 创建**布局树**，并计算元素的布局信息;
+ 对布局树进行分层，并生成**分层树**;
+ 为每个图层生成**绘制列表**，并将其提交到合成线程;
+ 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图;
+ 合成线程发送绘制图块命令**DrawQuad**给浏览器进程;
+ 浏览器进程根据 DrawQuad 消息**生成页面**，并**显示**到显示器上。

----

- 重排   
> 如果通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫**重排**。无疑，**重排需要更新完整的渲染流水线，所以开销也是最大的**。

- 重绘   
> 如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫**重绘**。相较于重排操作，**重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些**。

- 直接合成阶段
> 那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做**合成**。
> 例如，我们使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以**相对于重绘和重排，合成能大大提升绘制效率**。




