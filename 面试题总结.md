## 记录一些有意思的前端面试题，并不一定是真实的面试题，也包括一些自己的思考。

### 1、为什么浏览器会有同源策略？服务端可以直接请求而浏览器上不行？（比如一个ajax请求，就会有同源限制，而如果服务端node之类的一个相同的http请求就不会有同源策略的限制）

> 纯自己理解：说白了一个原因，就是安全性；因为http请求是会带着当前域名下的cookie的，如果跨域没限制，那么各网站都可以拿到其它站点的cookie了，就完全乱套了；服务端发送http请求并不会有这个问题，因为不会自带cookie。至于具体的跨域策略，此处就忽略了。

### 2、用 == 判等的时候的类型转换问题？（这个问题说白了就是ECMA规范的问题，例子如下，如果比较 x == y，规则如下）

> + 如果x的类型和y的类型相同，则直接返回 x === y; 
>
> + 如果x是undefined，y是null，返回true（反之也成立）;
>
> + 如果x为Number，y是String，则把String转换为Number后比较;
>
> + 如果x或者y是Boolean，则把Boolean转换为数字后和另外的值比较;
>
> + 如果x是String、Number或者Symbol且y的值为Object，则比较ToPrimitive(x) == y;
>
> + Reutrn false;

### 3、let,const,var的区别

> + let和const不会提升变量;
>
> + let和const会有块级作用域;
>
> + let和const重复声明会报错;
>
> + const声明一个常量，不可改变（如果声明的是对象，那么不能改变的是对象的引用地址）;
>
> + let和const如果在声明变量前使用，会抛出错误（形成暂时性死区）;
>
>> 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

### 4、生成一个长度为5的数组，然后随机生成5个[2, 32]之间不重复的数字放入数组中，用递归实现。

> 这是在网上看到的一个网友真实遇到的面试题，本身没什么难度，但是很多小细节需要注意，不要在一些不应该出错的地方翻车。
>
> 数组定义时候固定长度的方式；
>
> 一旦数组定义了长度n，则push操作只能push到n + 1的位置，所以不能用push来赋值；
>
> 生成任意区间随机数的方法还是应该很快写出来；
>
```js
    // 这种方式定义数组，如果只传一个>=0的数字，则会把数字当作默认的数组长度（数组本身为空）
    var arr = new Array(5)
    var len = 0
    function genArr(num) {
        if (len === arr.length) {
            console.log(arr)
            return
        }
        if (arr.indexOf(num) < 0) {
            arr[len] = num
            len++
        }
        genArr(2 + Math.floor(Math.random()*10*3))
    }
    genArr(2 + Math.floor(Math.random()*10*3))
```

### 5、substring 和 substr 的区别

+ substring() 方法返回一个字符串在开始索引到结束索引之间的一个子集，或者从开始索直到字符串末尾的一个子集

> str.substring(start[, end])
>
> - 如果 start 等于 end ，substring 返回一个空字符串；
>
> - 如果省略end，substring 提取字符一直到末尾；
>
> - 如果任一参数小于 0 或为 NaN，则被当作 0；
>
> - 如果任一参数大于字符串 str.length，则被当作 str.length；
>
> - 如果 start 大于 end，则 substring 的执行会调换两个参数。

+ substr 被认作是遗留的函数应该避免使用，它并非JavaScript核心语言的一部分，未来将可能会被移除掉。如果可以的话，使用 substring 替代它。

> str.substr(start[, length]) 需要注意的点如下：
>
> - 如果 start 为正值，且大于或等于字符串的长度，则 substr 返回一个 空字符串；
>
> - 如果 start 为负值，则 substr 把它作为从字符串末尾开始的一个字符索引。如果 start 为负值且 abs(start) 大于字符串的长度，则 substr 使用 0 作为开始提取的索引。
>
> - 如果 length 为 0 或者 负值，则 substr 返回一个空字符串。如果忽略 length，则 substr提取字符，直到字符串末尾。

## 今天开始按天来准备题目和概念，不以单一的题目作为输出。

### 5月29日

+ JavaScript的事件循环？

> js是单线程语言（原因除了涉及到Dom的原因，总不能多个地方同时操作同一个Dom元素，还有就是在浏览器中，最主要的功能是和用户互动，多线程会带来其它复杂的同步问题），任务要排队执行，如果一个任务执行的事件太长，后面都得排队等待。于是 Event Loop 就来背单线程的锅了。

> + 首先代码进入执行栈，包括异步的操作；

> + 同步代码立即执行，出栈；

> + 异步代码去执行相应的api，执行栈继续往后执行；

> + 异步操作结束之后，相应的回调函数会进入任务队列；

> + 执行有空时来任务队列拿对应的函数，放入执行栈执行；

> + 任务队列包括 宏任务队列 和 微任务队列，执行栈为空的时候，系统会优先处理微任务队列，处理完微任务队列的所有任务后，再处理宏任务队列。

> 来一道题目好了

```js

    async function async1() {
        console.log('async1 start');
        await async2();
        console.log('async1 end');
        // Promise.resolve().then(() => console.log('async1 end'));
    }
    
    async function async2() {
        console.log('async2');
    }
    
    console.log('script start');
    
    setTimeout(function () {
        console.log('setTimeout');
    }, 0);
    
    async1();
    
    new Promise(function (resolve) {
        console.log('promise1');
        resolve();
    }).then(function () {
        console.log('promise2');
    });
    
    process.nextTick(() => {
        console.log('nextTick');
    })
    
    console.log('script end');

```

+ 一道题

```js
    console.log(foo);

    function foo(){
        console.log("foo");
    }

    var foo = 1;
```

> 这个地方是会打印函数的，因为在进入执行上下文时，首先会处理函数声明，其次处理变量声明，如果变量名称和已经声明的 形参 或 函数相同，则变量声明不会干扰已经存在的这类属性；反之亦然（如果同名的是函数表达式和函数声明，则执行的是以最后一个声明的形式）。

```js

    var foo = 1
    function foo() {

    }
    console.log(foo) // 1

    or
    
    var foo = 1
    var foo = function () {}
    console.log(foo) // function

    or

    function foo() {}
    var foo = 1
    console.log(foo) // function

    or

    function foo() {
        console.log('foo')
    }
    var foo = function () {
        console.log('exp')
    }
    foo() // exp

    or

    var foo = function () {
        console.log('exp')
    }
    function foo() {
        console.log('foo')
    }
    foo() // exp


```

### 5月30日

+ 实现一个丐版的 Promise
```js
    const PENDING = 'pending'
    const RESOLVED = 'resolved'
    const REJECTED = 'rejected'
    class Mypromise {
        constructor(fn) {
            this.state = PENDING;
            this.value = null;
            this.resolveCallback = [];
            this.rejectCallback = [];
            this.resolve = (val) => {
                setTimeout(() => {
                    this.value = val
                    if (this.state === PENDING) {
                        this.state = RESOLVED;
                        if (this.resolveCallback && this.resolveCallback.length > 0) {
                            this.resolveCallback.map(fn => {
                                if (fn && typeof fn === 'function') {
                                    fn.call(this, this.value);
                                }
                            })
                        }
                    }
                })
            }
            if (fn && typeof fn === 'function') {
                fn.call(this, this.resolve, this.reject)
                // fn(this.resolve, this.reject)
            }
        }

        reject(val) {
            setTimeout(() => {
                this.value = val
                if (this.state === PENDING) {
                    this.state = REJECTED;
                    if (this.rejectCallback && this.rejectCallback.length > 0) {
                        this.rejectCallback.map(fn => {
                            if (fn && typeof fn === 'function') {
                                fn.call(this, this.value);
                            }
                        })
                    }
                }
            })
        }

        then(onFulfill, onReject) {
            const _this = this;
            if (!onFulfill || typeof onFulfill !== 'function') {
                onFulfill = v => v;
            }
            if (!onReject || typeof onReject !== 'function') {
                onReject = (err) => { throw err };
            }
            if (_this.state === PENDING) {
                return new Mypromise(function(resolve, reject) {
                    _this.resolveCallback.push(() => {
                        let p2 = onFulfill(_this.value)
                        _this._resolvePromise(p2, resolve, reject)
                    })
                    _this.rejectCallback.push(() => {
                        let p2 = onReject(_this.value)
                        _this._resolvePromise(p2, resolve, reject);
                    })
                })
            } else if (_this.state === RESOLVED) {
                return new Mypromise(function(resolve, reject) {
                    try {
                        let p2 = onFulfill(_this.value)
                        _this._resolvePromise(p2, resolve, reject)
                    } catch (error) {
                        reject(error)
                    }
                })
            } else {
                return new Mypromise(function(resolve, reject) {
                    try {
                        let p2 = onReject(_this.value)
                        _this._resolvePromise(p2, resolve, reject);
                    } catch (error) {
                        reject(error)
                    }
                })
            }
        }

        _resolvePromise(p2, resolve, reject) {
            if (p2 instanceof Mypromise) {
                p2.then(res => {
                    try {
                    this._resolvePromise(res, resolve, reject);
                    } catch (error) {
                        reject(error)
                    }
                })
            } else {
                resolve(p2)
            }
        }
    }
```


### 6月4号

+ new运算符原理

```js
    function new1(fn) {
        var o = Object.create(fn.prototype)
        var r = fn.call(o)
        if (typeof r === 'object') {
            return r
        } else {
            return o
        }
    }
```

### 6月5号

+ 实现 bind,call,apply


+ 实现 继承函数

```js

    function Parent1() {
        this.name = 'p1'
    }
    function Child1() {
        this.type = 'c1'
        Parant1.call(this)
    }
    Child1.prototype = Object.create(Parent1.prototype)
    Child1.prototype.constructor = Child1

```
### 6月6日

+ 常规面试类型

 > 渲染机制

 > JS运行机制

 > 页面性能
 
 >> 预解析DNS 
 
 >> 强制打开页面a标签dns预解析

 >> <meta http-equiv="x-dns-prefetch-control" content="on">
 
 >> <link rel="dns-prefetch" href="xxx.com">

 >> 异步加载脚本方式：1、动态脚本加载；2、defer；3、async

 >> defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行

 >> async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关

 > 错误监控

 >> try...catch window.onerror

 >> 资源加载错误 performance.getEntries() window.addEventListener('error', fn)

 >> 错误上报 利用Image对象上报 (new Image()).src = 'xxx'


 ### 6月8日
